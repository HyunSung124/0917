# a = [4,1,2,3]
# b=[5,6]
# 자료형의 참과거짓 => 자료형의 값이 존재하면 참, 없으면 거짓
# a.sort(reverse=0)
# a.extend(8,7,6,8)#확장
# print(a)
# a = (1, )
# b = tuple([1,2,3,4])
# c = 1,
# print(type(c))
# 딕셔너리
# d = {}
# d["A"] = 1
# d["B"] = 2
# d["C"] = 3
# #딕셔너리 수정
# d["A"] = 4
# d["B"] = 5
# d["C"] = 6
# #딕셔너리 key - value 삭제
# del d['C']
# print(d)

# 딕셔너리 멤버 메소드
# 딕셔너리의 키값들만 모으기
# print(d.keys())
# 딕셔너리의 벨류값들만 모으기
# print(d.values())
# 딕셔너리의 (키,벨류) 모으기
# print(d.items())

# update()
# b = {"C": 3,"D":2}
# d.update(b)
# print(d)

# print('A' in d.keys())
# print('A' in d)


# 집합의 특징
# 1. 중복된 값이 없다.
# l = [1,2,3,1,1,3,2,3,1,2,3,1,4,2,4,2,3,2,1,2,1,3,4,2]
# s = set(l)
# print(s)
# #2.순서가 없다.
# a = "Hello"
# s2 = set(a)
# print(s2)

# A = {1,2,3,4}
# B = {3,4,5,6}
#
# #합집합 두개 이상의 집합의 합 shift + \(백슬레시) => |
# print(A | B)
# #차집합 A - B == A에서 B와 공통된 부분을 뺀 나머지
# print(A - B)
# #교집합 집합들의 공통된 부분들 A & B
# print(A & B)


#별찍기
#1
# n = int(input())
# for i in range(1,n+1):
#     print('*' * i)

#2
# for i in range(1,n+1):
#     print(' '* (n-i) + '*' * i)

#3
# for i in range(n,0,-1):
#     print('*'* i)

#4
# for i in range(n,0,-1):
#     print(' '* (n-i) + '*' * i)

#5
# for i in range(1,n+1):
#     print(' '* (n-i) + '*' * (2*i-1))

#6
# for i in range(n):
#     print(' ' * i + '*' * (2 *(n - 1) - 1))
